Okay, here is a technical proposal for updating the mana tracking system, incorporating the requirements from the parsing guide and addressing the issues we've found in the logs.

-----

## Technical Proposal: Refactoring Mana Generation and Tracking

**Date:** October 29, 2025
**Author:** Gemini (AI Assistant)
**Status:** Proposed

**1. Introduction & Goal**

The current mana tracking system in the simulation engine, particularly the `generateMana` function executed during the untap step, fails to accurately calculate the available mana pool based on the permanents on the battlefield. It relies on incorrect heuristics, ignores certain mana sources (like artifacts or specific land abilities), and miscalculates color availability. This leads to critical simulation failures and prevents accurate testing.

The goal of this refactor is to implement a robust and accurate mana tracking system that:

  * Correctly calculates the potential starting mana pool during the untap step by scanning **all** relevant permanents on the battlefield.
  * Strictly adheres to the output of the `cardBehaviorAnalyzer.js` and the rules defined in the **"Mana Ability Parsing & Implementation Guide"**.
  * Accurately tracks mana additions and subtractions within each phase/step based on game actions (`playLand`, `castSpell`, `activateAbility`).
  * Provides clear and detailed logging for debugging purposes.

**2. Core Component: Mana Pool Representation**

The mana pool will be represented consistently throughout the simulation as a JavaScript object:

```javascript
// Represents the currently available mana
let manaPool = {
  W: 0, // White
  U: 0, // Blue
  B: 0, // Black
  R: 0, // Red
  G: 0, // Green
  C: 0, // Colorless
  // Optional: Add structures to track choices or restrictions if needed later
};
```

This object will be initialized/reset during the untap step and then mutated by subsequent game actions within a phase/step before being emptied according to Magic rules.

**3. Phase 1: Untap Step Mana Generation (Refactor `generateMana`)**

The `generateMana` function (currently in `gameEngine.js`) must be completely rewritten. Its sole responsibility is to calculate the **total potential mana** available from **untapped permanents** at the start of the turn.

**Process:**

1.  **Initialize Pool:** Start with an empty `manaPool` object (all values set to 0).
2.  **Iterate Permanents:** Loop through **all** permanents the player controls on the `gameState.battlefield`.
3.  **Check Status:** For each permanent, check if it is **untapped**. If tapped, skip to the next permanent.
4.  **Retrieve Parsed Abilities:** Access the permanent's pre-parsed mana ability data (generated by `cardBehaviorAnalyzer.js` based on the "Mana Ability Parsing & Implementation Guide").
5.  **Evaluate Each Mana Ability:** For *each* mana ability listed for the permanent:
      * **Check `isManaAbility`:** If `false`, ignore this ability.
      * **Check Activation Cost:**
          * If `activationCost` contains only `{T}` (or is empty for static abilities), proceed.
          * If `activationCost` contains **any mana cost** (e.g., `{1}`, `{G}`, `{G/W}`), **ignore this ability** during the untap step calculation (as mana costs cannot be paid from an empty pool).
          * If `activationCost` contains other costs (e.g., `sacrifice`, `pay life`), these do *not* prevent calculation of potential mana *unless* the AI later decides not to pay them. Assume potential is available for now.
      * **Check Conditions:** Evaluate any `conditions` against the current `gameState`. If conditions are not met (e.g., `Tainted Isle` requires a Swamp, but none are controlled), ignore this ability.
      * **Add Potential Mana:** If the ability is usable (untapped, no prohibitive cost, conditions met), add its potential mana contribution to a *temporary representation* of the pool. Handle different `produces` types:
          * **Specific Mana:** (`{ quantity: 1, types: ["B"] }`) -\> Add `{B: 1}` to potential. (`{ quantity: 2, types: ["C", "C"] }`) -\> Add `{C: 2}`.
          * **Choice:** (`{ quantity: 1, types: [{ choice: ["U", "B"] }] }`) -\> Represent this choice. The pool needs a way to track "1 mana that can be U or B". This could be a separate array or properties, e.g., `choices: [{ amount: 1, colors: ['U', 'B'] }]`. The final pool structure needs careful design here. *For simplicity initially, we might just add the first option (e.g., +1 U) but log the choice, or represent generic mana that can be colored later.* **Recommendation:** Track choices explicitly if possible.
          * **Variable/Complex:** Ignore abilities producing variable mana (e.g., `X=count(...)`) during the *untap step calculation*, as these require runtime context/decisions. Focus only on fixed mana potential.
6.  **Finalize Pool:** Sum all contributions into the main `manaPool` object.
7.  **Logging:** Implement detailed logging during this process (as previously discussed):
    ```
    üîç [generateMana] Calculating potential mana...
      Permanent: Swamp (Untapped) -> Ability '{T}: Add {B}' -> Contributing: {B: 1}
      Permanent: Island (Untapped) -> Ability '{T}: Add {U}' -> Contributing: {U: 1}
      Permanent: Underground River (Untapped) -> Ability '{T}: Add {C}' -> Choice 1: {C: 1}
      Permanent: Underground River (Untapped) -> Ability '{T}: Add {U} or {B}' -> Choice 2: {U: 1} | {B: 1}
      Permanent: Great Hall (Untapped) -> Ability '{T}: Add {C}' -> Contributing: {C: 1}
      Permanent: Great Hall (Untapped) -> Ability '{1},{T}: Add two...' -> SKIPPED (Requires Cost {1})
      Permanent: Talisman of Dominance (Untapped) -> Ability '{T}: Add {C}' -> Contributing: {C: 1}
      Permanent: Talisman of Dominance (Untapped) -> Ability '{T}: Add {U} or {B}' -> Choice 3: {U: 1} | {B: 1}
    üîç [generateMana] Final Potential Pool: { U: X, B: Y, C: Z, Choices: [...] } // Reflects summed potential including choices
    ```

**4. Phase 2: Intra-Turn Mana Updates**

The simulation loop must maintain the `manaPool` object persistently *within* each step/phase where mana can be spent.

**Process Updates for Actions:**

1.  **`playLand`:**

      * After a land successfully enters the battlefield:
      * Check if it entered **untapped**.
      * If untapped, immediately **re-evaluate its mana abilities** (using logic similar to Step 5 above, excluding variable mana) and **add its potential mana** directly to the *current* `manaPool`.
      * Log this addition clearly (e.g., `‚äï Mana added from playing Island: +{U: 1}. New Pool: ...`).

2.  **`castSpell` / `activateAbility`:**

      * **Affordability Check:** Before execution, validate if the spell/ability cost can be paid from the *current* `manaPool`. This check MUST correctly handle:
          * Specific colored mana requirements.
          * Generic mana costs (can be paid by any color or colorless).
          * Paying costs using available "Choice" mana appropriately.
      * **Cost Subtraction:** If affordable, **accurately subtract** the mana cost from the `manaPool` object, prioritizing colored mana payment where required.
          * Log the subtraction clearly (e.g., `‚äñ Mana spent for Ponder ({U}): -{U: 1}. New Pool: ...`).
          * If an ability *produces* mana (e.g., Dark Ritual, mana activation on Talisman), add the produced mana to the pool *after* subtracting the cost.

3.  **Pool Emptying:** Ensure the `manaPool` is reset to `{ W: 0, ... C: 0 }` at the end of each step and phase as per Magic rules (e.g., end of combat step, end of main phase).

**5. Integration with AI**

The **current, up-to-date `manaPool` object** (reflecting additions from lands played and subtractions from spells cast *so far* in the current step/phase) **must** be provided to the AI as part of the game state context for **every decision prompt**.

**6. Dependencies**

This refactor relies entirely on the `cardBehaviorAnalyzer.js` producing accurate, structured mana ability data according to the **"Mana Ability Parsing & Implementation Guide"**. Any errors in the parsed data will lead to incorrect mana calculations.

**7. Testing Recommendations**

  * Test with various land types: Basics, untapped duals (`Underground River`), conditional untapped (`Drowned Catacomb`), conditional activation (`Tainted Isle`), costed activation (`Great Hall`), lands entering tapped (`Minas Morgul`).
  * Test with mana artifacts (`Signets`, `Talismans`, `Sol Ring`).
  * Test with mana creatures (`Birds of Paradise`).
  * Verify multi-spell turns utilizing different colors accurately deplete the pool.
  * Verify scenarios where the AI should correctly identify insufficient mana (especially specific colors).
  * Test mana generation immediately after a land enters untapped mid-turn.

**8. Logging (Reiteration)**

The detailed, per-permanent logging during the `generateMana` (untap) step is critical for debugging and verifying this refactor. Clear logging of mana additions (`playLand`) and subtractions (`castSpell`, `activateAbility`) is also essential.

-----